===== TABLE OF CONTENTS =====

SANDBOX_temp.py is a scratch file, always changing it
SANDBOX_temp2.py ditto

SANDBOX.ipynb is just random jupyter stuff (mostly for messing with plots for a figure)

SANDBOX.py & SANDBOX2.py are comboboxes with checkable options in the popup

SANDBOX3.py is a editable checkbox with fixed options (takes advantage of completer), with mouse click event handling
SANDBOX3_barebones.py is the raw code from the stackoverflow post that said to use completer

SANDBOX4.py is a QWebEngineView example (browser inside pyqt app)

SANDBOX5.py is draggable table rows (similar to notion and wtv that javascript element is called. draggable grid row on that generatedata site)

SANDBOX6.py is a measure of API call speeds (rcsb classification and emdb qscore/atom)
SANDBOX7.py is measuring get_qscore function from z_fetch_sample_info with dif number of max_workers

SANDBOX8 & SANDBOX8_2.py are single and multiple tqdm -> pyqt progressbars
    https://stackoverflow.com/a/74091829
    https://gist.github.com/LoneWanderer-GH/ec18189a8476adb463531a68430e94a8

SANDBOX9.py runs get_qscore fxn in backend connected to a qprogressbar (emits an integer that gets summed up later)

SANDBOX10.py is 

SANDBOX11.1 - 11.5.py is iterations of QTreeWidget (for labels)
SANDBOX11.6.py is the NoEditDelegate example (column specific editing) from stackoverflow: https://stackoverflow.com/a/4657065
SANDBOX11.7.py is a similar column specific editing that uses the builtin open/closePersistentEditor, but it needs a bit more work rn bc its not closing the persistentEditor properly (https://www.qtcentre.org/threads/4709-QTreeWidget-item-editing-want-column-specificity)

SANDBOX12.py is completely UNNEEDED. shows how to make a custom spinbox and override some settings butttt in pyqt5, it's now a built in feature in qt designer (suffix property).

SANDBOX13.py is dependent spinboxes with max limit (ChatGPT generated code tho so rewrite, dont push chatgpt code into codebase lol)

SANDBOX14.py is an example with QUndoStack  (ChatGPT generated tho so lol dont trust the quality, just for a quick demo to see if can work)

SANDBOX15.py is testing a datastructure for labels. List of list of dictionaries. Inner list's first element is a string of the group name, then the dictionaries follow.
    > need to modify graysons code or make a wrapper to do with that extra string (group names)

    another approach is to just have a list of dicts, and then groups are like a virtual layer
    each label gets a unique id, like "group2_label3". So the id is just generated based on the context of the GUI. 
    makes indexing more annoying tho. like either need a separate 2d array or dict to hold the number of labels per group
        like this: group 1 - 7 labels
                   group 2 - 3 labels
                   group 3 - 2 labels
    Then the index of group 3 label 2 is just the 7+3+2-1. Like list[7+3+2-1]. Need a fast way to calculate this.
    Deletion should be easy. But the group numbers/names in the id's have to autoincremented ones instead of the user controlled ones cuz thatd be a mess. Also doesnt matter cuz groups in this appraoch are virtualized in the backend. But would still need to incorporate the user inputted group names (prob thru parameter in some wrapper fxn).
    Insertion is fine if you dont care about order (nvm can just look for label with same group number and then label number - 1). 
        But retrieval will be more annoying (tho might have to go thru entire list anyways).
    Seems like performance could likely be worse.
    SOO first approach prob better. Simpler for developer too. Prob not significant memory cost b/c these group of labels are fairly small. Butttt uhh maybe hardcode a max value (if qt doesnt have a default one for list widgets). This is more of a gui thing for setting max labels.

SANDBOX16.py is a demo of the 3 dif (builtin) completion modes for QCompleter (p useless outside of just visualizing a builtin property)

SANDBOX17.py is has rearrangeable tabs and tabs on the side

SANDBOX18.py is a quick GPT example of logging handler to display in QTextEdit (DONT use)
    log.txt is a log file generated by this code
SANDBOX18_improved.py is a better stack post: https://stackoverflow.com/questions/28655198/best-way-to-display-logs-in-pyqt
    EDIT: do NOT use this. only for single thread (even some Qt classes that are thread safe are actually not single threaded, for ex. QFileSystemModel)

SANDBOX19.py is a qpushbutton overlayed on a qlineedit from this stack post converted to pyqt5: https://stackoverflow.com/a/46693142. And then I added a QLabel to it in the same style as the button
    BUT this is actually the WRONG way to approach this
    you actually WANT the lineedit and tags to be separate (so respects boundaries) like here: https://robonobodojo.wordpress.com/2018/09/11/creating-a-tag-bar-in-pyside/
SANDBOX19_complement.py is https://robonobodojo.wordpress.com/2018/09/11/creating-a-tag-bar-in-pyside/ converted to pyqt5
    BETTER approach will be to just mess with stylesheets similar to how i made the custom searchbars with button embedded.
    USE this one to test in main gui
SANDBOX19_complement_demo.py is just a demo with a simple mainwindow. Wrapped the custom tagbar class with an empty widget. (Using widgets like divs lol)
**IMPORTANT**
    zTag_main_alt_allcode_v2 and SANDBOX19_complement_demo.py go hand in hand. two dif approaches to same problem (p much the same). currently using zTag_main_alt_allcode_v2
    but work on SANDBOX19_complement_demo.py to catch it up and see if can implement same features (edit should be p easy, just use same approach. only dif is how widgets are added. need to copy the eventfilter fxn too)



SANDBOX20_memorymanagement.py is a demo from this stack post
SANDBOX20_printwidgets.py was originally just a print widgets fxn (used dif method from that stack post), BUT i pasted all the important code from the SANDBOX20_memorymanagement over,
    so now they basically behave the same

    > QWidget's close behavior (like widget.close()): For top-level widgets like windows or dialogs, close() will hide the widget. For child widgets, calling close() will just hide them and not affect their parent.
    > Memory management: If Qt.WA_DeleteOnClose is set to True, the widget will be deleted when closed. Otherwise, it will remain in memory until explicitly deleted.

    ran both with task manager open, and you can actally see the memory usage increase in real time. when widget count went from 436 - 501, memory usage went from 18 to 19 mb
    1mb / 65 is about 15kb per widget (not terrible bc in total only 20ish mb for 500 widgets butttt should try to delete stuff properly if needed)


SANDBOX21_py is super trivial (only 2 lines matter). just showing tool tip on button click

SANDBOX22_py just shows all of Qt's builtin icons (https://www.pythonguis.com/faq/built-in-qicons-pyqt/)

SANDBOX23_customtreerowPoC (proof of concept) is gpt generated. not using that code, just a proof of concept to see if this approach is viable or a waste of time.
SANDBOX23_sameidea is the same idea lol. source: https://stackoverflow.com/questions/72183924/add-custom-widget-to-a-qtreewidget-column-in-pyqt5

SANDBOX24_py is this stack example, allows real time completion checking in a comma separated single user input (https://stackoverflow.com/questions/3779720/qt-qcompleter-multiple-matches)

SANDBOX25_py is this tutorial (uses animations): https://www.pythonguis.com/tutorials/qpropertyanimation/#fn:1. EDIT: prob won't need this, but good example of how to implement animations
    edit: code copied into the GUI_custom_widgets folder under animated_toggle.py and test_animated_toggle.py
